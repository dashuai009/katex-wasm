use crate::build::HTML::IsRealGroup;
use crate::build::{common, mathML, HTML};
use crate::define::functions::public::{
    ord_argument, FunctionContext, FunctionDefSpec, FunctionPropSpec,
};
use crate::dom_tree::css_style::CssStyle;
use crate::dom_tree::span::Span;
use crate::mathML_tree::math_node::MathNode;
use crate::mathML_tree::public::MathNodeType::Math;
use crate::mathML_tree::public::{MathDomNode, MathNodeType};
use crate::mathML_tree::text_node::TextNode;
use crate::parse_node::types::ParseNodeToAny;
use crate::types::Mode;
use crate::utils::is_character_box;
use crate::Options::Options;
use crate::{parse_node, types::ArgType, AnyParseNode, HtmlDomNode};
use std::sync::Mutex;

// A map of CSS-based spacing functions to their CSS class.
// let cssSpace: {[string]: string} = {
// "\\nobreak": "nobreak".to_string(),
// "\\allowbreak": "allowbreak".to_string(),
// };

// A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.
// let regularSpace: {[string]: { className ?: string }} = {
// " ": {},
// "\\ ": {},
// "~": {
// className: "nobreak".to_string(),
// },
// "\\space": {},
// "\\nobreakspace": {
// className: "nobreak".to_string(),
// },
// };

// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.

pub fn html_builder(_group: Box<dyn AnyParseNode>, options: Options) -> Box<dyn HtmlDomNode> {
    let group = _group
        .as_any()
        .downcast_ref::<parse_node::types::spacing>()
        .unwrap();
    match group.text.as_str() {
        " " | "\\ " | "\\space" => {
            // Spaces are generated by adding an actual space. Each of these
            // things has an entry in the symbols table, so these will be turned
            // into appropriate outputs.
            if group.mode == Mode::text {
                let ord = common::make_ord(_group, options, "textord".to_string());
                return Box::new(ord) as Box<dyn HtmlDomNode>;
            } else {
                let res = common::make_span(
                    vec!["mspace".to_string()],
                    vec![Box::new(common::math_sym(
                        group.text.clone(),
                        group.mode,
                        options.clone(),
                        vec![],
                    )) as Box<dyn HtmlDomNode>],
                    Some(&options),
                    Default::default(),
                );
                return Box::new(res) as Box<dyn HtmlDomNode>;
            }
        }
        "~" | "\\nobreakspace" => {
            if group.mode ==Mode::text {
                let mut ord = common::make_ord(_group, options, "textord".to_string());
                ord.get_mut_classes().push("nobreak".to_string());
                return Box::new(ord) as Box<dyn HtmlDomNode>;
            } else {
                let res = common::make_span(
                    vec!["mspace".to_string(), "nobreak".to_string()],
                    vec![Box::new(common::math_sym(
                        group.text.clone(),
                        group.mode,
                        options.clone(),
                        vec![],
                    )) as Box<dyn HtmlDomNode>],
                    Some(&options),
                    Default::default(),
                );
                return Box::new(res) as Box<dyn HtmlDomNode>;
            }
        }
        "\\nobreak" | "\\allowbreak" => {
            // Spaces based on just a CSS class.
            return Box::new(common::make_span(
                vec!["mspace".to_string(), group.text[1..].to_string()],
                vec![],
                Some(&options),
                Default::default(),
            )) as Box<dyn HtmlDomNode>;
        }
        _ => {
            panic!("Unknown type of space \"{}\"", group.text);
        }
    }
}

fn mathml_builder(_group: Box<dyn AnyParseNode>, options: Options) -> Box<dyn MathDomNode> {
    let group = _group
        .as_any()
        .downcast_ref::<parse_node::types::spacing>()
        .unwrap();
    let node = match group.text.as_str() {
        " " | "\\ " | "\\space" | "~" | "\\nobreakspace" => {
            MathNode::new(
                MathNodeType::Mtext,
                vec![Box::new(TextNode::new("\u{00a0}".to_string())) as Box<dyn MathDomNode>],
                vec![],
            )
        }
        "\\nobreak" | "\\allowbreak" => {
            // CSS-based MathML spaces (\nobreak, \allowbreak) are ignored
            MathNode::new(MathNodeType::Mspace, vec![], vec![])
        }
        _ => {
            panic!("Unknown type of space \"{}\"", group.text);
        }
    };

    return Box::new(node) as Box<dyn MathDomNode>;
}

lazy_static! {
    pub static ref TAG: Mutex<FunctionDefSpec> = Mutex::new({
        let mut props = FunctionPropSpec::new();
        props.set_num_args(0);

        FunctionDefSpec {
            def_type: "spacing".to_string(),
            names: vec![],
            props,
            handler: |a, b, c| panic!("error"),
            html_builder: Some(html_builder),
            mathml_builder: Some(mathml_builder),
        }
    });
}
